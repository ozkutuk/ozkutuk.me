<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>ozkutuk's blog</title>
        <link>https://ozkutuk.me</link>
        <description><![CDATA[ozkutuk's blog]]></description>
        <atom:link href="https://ozkutuk.me/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Wed, 12 Mar 2025 00:00:00 UT</lastBuildDate>
        <item>
    <title>In praise of affine optics</title>
    <link>https://ozkutuk.me/posts/2025-03-12-affine-optics.html</link>
    <description><![CDATA[<p>Recently at work, I was tasked with picking a suitable optics library for our
team to use. More specifically, a library that we could migrate to from
<code>microlens</code>. In the end, we went with the <a href="https://hackage.haskell.org/package/optics"><code>optics</code></a> library. The
reasons for the migration and what went into the decision process could be the
topic of another blog post (one that I will hopefully write soon). However, in
this short post, I will talk about one of the‚Äîin my opinion, undersold‚Äîfeatures
provided by the <code>optics</code> library: <em>affine optics</em>. Considering that affine optics
do not exist in the <code>lens</code> library, one might assume that they are some obscure
optics that exist solely for novelty‚Äôs sake. In this post I will try to
convince you that, on the contrary, affine optics are very useful in
practice and should be something that exists in any working Haskell
programmer‚Äôs toolkit.</p>
<p>The rest of this post assumes basic familiarity with optics, specifically folds
and traversals. I will start with a <em>very</em> brief recap of what those are, but if
you need a more complete introduction to optics in general, I can suggest
<a href="https://hackage.haskell.org/package/lens-tutorial-1.0.5/docs/Control-Lens-Tutorial.html"><code>Control.Lens.Tutorial</code></a>.</p>
<p>Finally, a disclaimer: for the sake of clarity, I took the liberty to simplify
the type signatures of some <code>optics</code> definitions<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. However, if you want to
see the original definitions, I have provided links to the respective sections
of the documentation.</p>
<h2 id="folds-and-traversals-a-short-recap">Folds and traversals, a short recap</h2>
<p>In the documentation of <code>optics</code>, <a href="https://hackage.haskell.org/package/optics-core-0.4.1.1/docs/Optics-Fold.html#v:Fold"><code>Fold</code></a> is explained as follows:</p>
<blockquote>
<p>A <code>Fold S A</code> has the ability to extract some number of elements of type <code>A</code>
from a container of type <code>S</code>.</p>
</blockquote>
<p>The ‚Äúsome number‚Äù of elements mentioned in the quote could be zero, one, or any
other non-negative integer. That is, it can be conceptualized as retrieving a
list of values. In fact, we can do exactly that by using the <a href="https://hackage.haskell.org/package/optics-core-0.4.1.1/docs/Optics-Fold.html#v:toListOf"><code>toListOf</code></a>
eliminator:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Given a Fold that focuses both elements of tuples in a list, </span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>t pairs</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">pairs ::</span> <span class="dt">Fold</span> [(a, a)] a</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> toListOf pairs [(<span class="dv">1</span>, <span class="dv">2</span>), (<span class="dv">3</span>, <span class="dv">4</span>), (<span class="dv">5</span>, <span class="dv">6</span>)]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</span></code></pre></div>
<p><a href="https://hackage.haskell.org/package/optics-core-0.4.1.1/docs/Optics-Traversal.html"><code>Traversal</code></a> can be thought of as a <code>Fold</code> that can also be
used to update the value of its foci. This implies that a <code>Traversal</code> can be
used wherever a <code>Fold</code> is expected, but not vice versa. In fact, the <code>pairs</code>
<code>Fold</code> we had in the previous code snippet (whose definition is of no
importance) is actually a <code>Traversal</code>, so we can use it to, say, increment each
focused element:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- I lied, &quot;pairs&quot; is actually a Traversal</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- (that can also serve as a Fold)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>t pairs</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ot">pairs ::</span> <span class="dt">Traversal&#39;</span> [(a, a)] a</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> over pairs <span class="fu">succ</span> [(<span class="dv">1</span>, <span class="dv">2</span>), (<span class="dv">3</span>, <span class="dv">4</span>), (<span class="dv">5</span>, <span class="dv">6</span>)]</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>[(<span class="dv">2</span>,<span class="dv">3</span>),(<span class="dv">4</span>,<span class="dv">5</span>),(<span class="dv">6</span>,<span class="dv">7</span>)]</span></code></pre></div>
<p>Now that we are done with the recap, let‚Äôs get to the meat of the post (I told
the recap would be <em>very</em> brief, didn‚Äôt I?)</p>
<h2 id="enter-affine-optics">Enter affine optics</h2>
<p><code>Traversal</code> and <code>Fold</code> also have affine counterparts, aptly-named as
<a href="https://hackage.haskell.org/package/optics-core-0.4.1.1/docs/Optics-AffineTraversal.html"><code>AffineTraversal</code></a> and <a href="https://hackage.haskell.org/package/optics-core-0.4.1.1/docs/Optics-AffineFold.html"><code>AffineFold</code></a>.
Whereas a <code>Traversal</code><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> targets potentially zero, one, or multiple elements,
an <code>AffineTraversal</code> can only target either zero or one element. Consequently,
you can now use <a href="https://hackage.haskell.org/package/optics-core-0.4.1.1/docs/Optics-AffineFold.html#v:preview"><code>preview</code></a> to view the target value instead of <code>toListOf</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- _head :: AffineTraversal&#39; [a] a</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> preview _head [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span> <span class="dv">1</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> preview _head []</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="dt">Nothing</span></span></code></pre></div>
<p>The difference might seem insignificant at first glance. However, I would argue
that distinguishing affine optics from their regular counterparts is important
for a few reasons.</p>
<h3 id="affine-optics-are-a-natural-extension">Affine optics are a natural extension</h3>
<p>As mentioned above, <code>Traversal</code> can focus many elements. Therefore, <code>Traversal</code>
can be conceptualized as a list of values. That is, if you have a <code>Traversal' S A</code> at hand<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>, you can think of it as something that allows you to get a hold
of an <code>[A]</code> given an <code>S</code>.</p>
<p>If you can target a list of values through <code>Traversal</code>, how can you target an
optional value (i.e.¬†a <code>Maybe</code>)? That is exactly what <code>AffineTraversal</code> is for!
Just like how lists are ubiquituous in Haskell, <code>Maybe</code> is also indispensable
and ever-present in every Haskell codebase. Therefore, having an optic kind that
perfectly matches this pattern is certainly quite useful.</p>
<h3 id="affine-optics-provide-additional-type-safety">Affine optics provide additional type safety</h3>
<p>One can read the previous point and think, ‚Äúwell, <code>lens</code> users have been doing
without affine optics just fine‚Äù. Certainly, whatever <code>AffineTraversal</code>
provides, one can do pretty much the same with <code>Traversal</code>, just as one can
live without <code>Maybe</code> and just use singleton lists instead. Is that what we want
though? As Haskell programmers, we enjoy the fact that we can model the problem
domain precisely through the types. Preaching the motto ‚Äúmake illegal states
unrepresentable‚Äù, we shouldn‚Äôt settle for a <code>Traversal</code> if we know that it
could focus at most a single value anyway. <code>AffineTraversal</code> perfectly captures
this notion.</p>
<p>To put it in concrete terms, let‚Äôs try to <code>preview</code> a <code>Traversal</code> using both
<code>lens</code> and <code>optics</code> libraries and contrast the result:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- lens</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> preview pairs [(<span class="dv">1</span>, <span class="dv">2</span>), (<span class="dv">3</span>, <span class="dv">4</span>), (<span class="dv">5</span>, <span class="dv">6</span>)]</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span> <span class="dv">1</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- optics</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> preview pairs [(<span class="dv">1</span>, <span class="dv">2</span>), (<span class="dv">3</span>, <span class="dv">4</span>), (<span class="dv">5</span>, <span class="dv">6</span>)]</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span> [<span class="dt">GHC</span><span class="op">-</span><span class="dv">64725</span>]</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    ‚Ä¢ <span class="dt">A_Traversal</span> cannot be used as <span class="dt">An_AffineFold</span></span></code></pre></div>
<p>The difference is abundantly clear: <code>optics</code> code does not typecheck since a
<code>Traversal</code> (or a <code>Fold</code> for that matter) cannot be used as an <code>AffineFold</code>,
whereas <code>lens</code> happily accepts it by returning the first target and silently
discarding the rest.</p>
<p>Why is the <code>Traversal</code> being used as an <code>AffineFold</code> in the first place? Here
is the type of <code>preview</code> from <code>optics</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">preview ::</span> <span class="dt">AffineFold</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span></code></pre></div>
<p>As you can see, <code>preview</code> expects an <code>AffineFold</code>. It makes sense, since you are
trying to extract a single value, if it exists. What if you want the behavior of
<code>lens</code> though, i.e.¬†you want to extract the first target of the <code>Fold</code>? In that
case, you need to use a specialized combinator instead:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> headOf pairs [(<span class="dv">1</span>, <span class="dv">2</span>), (<span class="dv">3</span>, <span class="dv">4</span>), (<span class="dv">5</span>, <span class="dv">6</span>)]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span> <span class="dv">1</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- ...or you can turn &quot;pairs&quot; into an AffineFold that targets just</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- the first focus of the original Fold by using &quot;pre&quot;:</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> preview (pre pairs) [(<span class="dv">1</span>, <span class="dv">2</span>), (<span class="dv">3</span>, <span class="dv">4</span>), (<span class="dv">5</span>, <span class="dv">6</span>)]</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span> <span class="dv">1</span></span></code></pre></div>
<p>The point I am trying to get across is that <code>optics</code> (through making
<code>AffineTraversal</code> a distinct optic) forces the developer to make an explicit
decision on the behavior: you either use a <code>Fold</code> with <code>toListOf</code> to obtain a
list of values, or you <em>explicitly</em> pick the first target of it (if you want to
have the behavior <em>implicitly</em> provided by <code>lens</code>).</p>
<h3 id="affine-optics-are-everywhere">Affine optics are everywhere</h3>
<p>What about <code>Prism</code>s? They also can capture the notion of a single optional
value, right? Well, yes, but conceptually <code>Prism</code> generalizes the notion of a
constructor. This means that to be able to create a <code>Prism</code>, one also has to
provide a way to construct the ‚Äúbigger‚Äù type from the ‚Äúsmaller‚Äù one. This makes
<code>Prism</code>s much less generally useful compared to <code>AffineTraversal</code>s.</p>
<p>In contrast, once I started using the <code>optics</code> library, I have started to notice
affine optics everywhere. In hindsight, this is not a surprising result. Below
is the subtyping relation between the optic kinds:</p>
<figure>
<img src="https://hackage.haskell.org/package/optics-0.4.2/docs/diagrams/optics.png" alt="Subtyping hierarchy of optics" />
<figcaption aria-hidden="true">Subtyping hierarchy of optics</figcaption>
</figure>
<p>Notice the arrows going into <code>AffineTraversal</code> from <code>Lens</code> and <code>Prism</code>. This
means that both <code>Lens</code> and <code>Prism</code> can be used as <code>AffineTraversal</code>. A direct
implication of this is that you obtain an <code>AffineTraversal</code> if you compose a
<code>Lens</code> and a <code>Prism</code>. This <code>Lens</code>-<code>Prism</code> composition is very common in business
code that have lots of different record types modelling the problem domain.
Ignoring my lack of creativity for a moment, let‚Äôs take a look into this example
featuring the <code>Animal</code> type:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Animal</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Dog</span> <span class="dt">String</span> <span class="dt">DogBreed</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Cat</span> <span class="dt">String</span> <span class="dt">CatBreed</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">DogBreed</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a> <span class="ot">=</span> <span class="dt">Bulldog</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a> <span class="op">|</span> <span class="dt">Pomeranian</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a> <span class="op">|</span> <span class="dt">Other</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- data CatBreed = ...</span></span></code></pre></div>
<p>Then, the breed of a dog could be targeted like this<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="kw">let</span> myDog <span class="ot">=</span> <span class="dt">Dog</span> <span class="st">&quot;Missile&quot;</span> <span class="dt">Pomeranian</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- #_Dog :: Prism&#39; Animal (String, DogBreed)</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- _2    :: Lens&#39; (a, b) b</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> preview (<span class="op">#</span>_Dog <span class="op">%</span> _2) myDog</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span> <span class="dt">Pomeranian</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- can also be used for updates</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> set (<span class="op">#</span>_Dog <span class="op">%</span> _2) <span class="dt">Bulldog</span> myDog</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="dt">Dog</span> <span class="st">&quot;Missile&quot;</span> <span class="dt">Bulldog</span></span></code></pre></div>
<p>The optic used here is an <code>AffineTraversal</code>, because it is the composition of
<code>#_Dog</code> (which is a <code>Prism</code>) and <code>_2</code> (which is a <code>Lens</code>). You simply cannot
get by with a <code>Prism</code> here, because there is no general way to construct an
<code>Animal</code> given a <code>DogBreed</code>: what would the name of the dog be in such a
construction?</p>
<h2 id="conclusion">Conclusion</h2>
<p>Hopefully, this short post was enough to share my enthusiasm of affine optics. I
have been a happy <code>optics</code> user for a multitude of reasons, but I consider the
existence of affine optics to be one of the most prominent ones. If you are
looking for an optics library for your next project, consider giving <code>optics</code> a
go! Maybe you will enjoy using affine optics as much as I do.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Most notably, I have substituted some of the types with concrete optics
which in actuality are polymorphic types constrained by the <a href="https://hackage.haskell.org/package/optics-core-0.4.1.1/docs/Optics-Optic.html#t:Is"><code>Is</code></a>
typeclass. This typeclass captures the subtyping relation between kinds of
optics, hence allows one to, say, pass a <code>Lens</code> where a <code>Traversal</code> is
expected.<a href="#fnref1" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn2"><p>And likewise, a <code>Fold</code>. For the rest of this post, I will only talk about
<code>Traversal</code>s unless the distinction between a <code>Fold</code> and <code>Traversal</code> matters
for the point at hand.<a href="#fnref2" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn3"><p>If you are not too familiar with the optics libraries, the ‚Äú'‚Äù suffix
means that the <code>Traversal</code> is a ‚Äúsimple‚Äù one, i.e.¬†one that is not
type-changing. The difference is not important for the purposes of this
post.<a href="#fnref3" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn4"><p>This example makes use of the label optics derived through <code>Generic</code>, but
handwritten optics would work just as well. See the
<a href="https://hackage.haskell.org/package/optics-core-0.4.1/docs/Optics-Label.html"><code>Optics.Label</code></a> module if you want to follow along.<a href="#fnref4" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
</ol>
</section>]]></description>
    <pubDate>Wed, 12 Mar 2025 00:00:00 UT</pubDate>
    <guid>https://ozkutuk.me/posts/2025-03-12-affine-optics.html</guid>
    <dc:creator>Berk √ñzk√ºt√ºk</dc:creator>
</item>
<item>
    <title>New blog post published on Tweag's blog</title>
    <link>https://ozkutuk.me/posts/2023-01-31-new-blog-post.html</link>
    <description><![CDATA[<p>I recently published a post on <a href="https://www.tweag.io/blog">Tweag‚Äôs blog</a>, detailing my internship experience working on Haskell Language Server: <a href="https://www.tweag.io/blog/2023-01-31-hls-internship-report">‚ÄúA Semester of HLS: An Internship Report‚Äù</a>.</p>]]></description>
    <pubDate>Tue, 31 Jan 2023 00:00:00 UT</pubDate>
    <guid>https://ozkutuk.me/posts/2023-01-31-new-blog-post.html</guid>
    <dc:creator>Berk √ñzk√ºt√ºk</dc:creator>
</item>
<item>
    <title>Raiden, Part III: Adding Movement</title>
    <link>https://ozkutuk.me/posts/2019-06-21-adding-movement.html</link>
    <description><![CDATA[<p>After a slight detour from our raytracer to research a bit about ray marching, we are back again. This time we will be adding transformations and instancing to Raiden. We will talk in a lot more detail in their dedicated chapters, but just to give a brief idea of what we are about to do for those who are unfamiliar with the terminology:</p>
<p>Transformations are pretty self-explanatory. We will be applying certain operations to our objects to ‚Äútransform‚Äù them. We will cover translation, scaling and rotation. It is important to note that we will be doing these in such a way that we will <em>not</em> be modifying the object geometry. We will be achieving the transformations with the help of our good ol‚Äô matrices. The benefits of not manipulating the object geometry directly may not be too obvious for now, but it will be useful once we start implementing instancing.</p>
<p>Instancing is method to save additional memory cost in the case where there exists duplicates of a single complex mesh in the scene. We call these duplicates, well‚Ä¶ instances. I think it is safe to say that instancing is a space optimization. We will see how it works in its own section, but I think this explanation is enough for now to get going.</p>
<h2 id="transformations">Transformations</h2>
<p>If you were following closely, I mentioned that we will be making use of matrices to perform our transformations. But we don‚Äôt have any matrix implementation in our project yet. After thinking for a while, I thought implementing a reliable math library with full matrix and vector support was too much work and decided to integrate <a href="https://glm.g-truc.net/0.9.9/index.html">GLM</a> into the project. GLM provides all the math stuff with a very similar interface to GLSL. Since it is designed with use in graphics work in mind, it has the common functionality we will need. With the integration of GLM, it was the time to say goodbye to <code>tinymath</code>. It was a small library we rolled on our own but served us well until this time. Actually, I had used GLM in my other side graphics projects which involved OpenGL stuff. I was familiar with its architecture and it was a pleasant experience to use, therefore I designed <code>tinymath</code> with an interface very similar to GLM. This resulted in a very smooth migration phase, which was mostly converting <code>tmath::vec3f</code> to <code>glm::vec3</code> and it was good to go.</p>
<p>Now that we have our math library at our disposal, we can start to actually implement the transformation stuff. We hopefully need not worry about matrix calculations, GLM takes care of it with its convenient functions. There are only a few points we need to be careful about.</p>
<p>Let‚Äôs discuss how this all comes together. I mentioned that we will not be modifying the object geometry, so what are we going to do? We can represent all our transformations, that is rotation, scaling and translation, with a matrix. We call this matrix a transformation matrix. I will not go into too much detail regarding the math part, but we know that by the properties of matrices and a few clever tricks, we can combine these different kinds of transformations by multiplying their corresponding matrices, resulting in a single transformation matrix.</p>
<p>The actual question is: how do we use this matrix? I think it is obvious that we can simply modify our objects‚Äô <code>hit</code> routines to apply this transformation. Let‚Äôs consider meshes: we could multiply our transformation matrix with all the vertices of our mesh, inside the <code>hit</code> function. And it <em>would</em> work. But we can do better. Let‚Äôs think for a second. Rather than transforming our objects, we can <em>inverse</em> transform the ray, and their relative positions and orientations will be the same. The upside is it would be a lot, <em>a lot</em> faster.</p>
<p>One thing we need to be careful about is the case of non-uniform scaling. We can scale our objects in a non-uniform fashion. For example, we can scale a sphere 2x its size, but only on x-axis. This would yield an ellipsoid. We do not have a <code>hit</code> routine for ellipsoids, but the god part is we don‚Äôt need it. We can use our usual sphere hit function, and transform the result. However, in order to get a correct result, we need to treat the surface normal vector differently. We basically need to multiply it with the inverse transpose of the transformation matrix, and it just works‚Ñ¢.</p>
<p>The actual part we need to think thoroughly, is about BVH. If we do not transform the bounding boxes of our objects along with them, we are no good. I know that it is a bit hard to visualize, I know it is for me. But bear with me. While we are constructing the BVH, we are in the <em>world space</em>. Therefore we need to create the bounding boxes of the BVH as if we transformed our objects. However, once we hit a bounding box of the BVH, we move the <em>local space</em> of our object, therefore we don‚Äôt transform an objects internal bounding box, we just inverse transform the ray. I hope that makes sense. It took me a lot of thinking to grasp the idea, and I am still not totally sure I got it right üòÑ.</p>
<p>After we implement the corresponding parser stuff for our transformations, and put all these together, we can have the following outputs:</p>
<figure>
<img src="/assets/bunny_rotated.png" alt="Bunny, rotated on -axis" />
<figcaption aria-hidden="true">Bunny, rotated on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>-axis</figcaption>
</figure>
<p>I rendered a few of the above with differing rotation angles to produce this animation:</p>
<figure>
<img src="/assets/bun.gif" alt="Bunny, animated" />
<figcaption aria-hidden="true">Bunny, animated</figcaption>
</figure>
<p>I also rendered this scene of the so-called ‚Äúkilleroo‚Äù, however there seems to be problem with refractive surfaces under transformation. I have yet to solve the issue. However transformations are correct:</p>
<p><img src="/assets/killeroo_glass.png" alt="Killeroo" /><br />
</p>
<h3 id="instancing">Instancing</h3>
<p>In the intro paragraph I have talked a bit about what instancing is. As I said, instancing is a way to save memory for the cases where there exists multiples of the same mesh. What I mean by the same mesh is, only the same geometry. The instances will most probably have a different position, orientation and it may have different materials. These are all okay. After all, the costly part for us is the object geometry, memory-wise.</p>
<p>The idea is simple and intuitive. For our instances, we do not create a whole new mesh in the memory. Instead we define a <code>MeshInstance</code> class, which holds a pointer to the base mesh, and also has its own transformation matrix and material. In the <code>hit</code> function of our <code>MeshInstance</code>, we just call the <code>hit</code> function of the base mesh. During this process, we apply the transformation of the instance ofcourse. The same principles apply as explained in previous section. Another thing we may or may not want to have is to apply the transformation on top of the base mesh‚Äôs own transformation matrix, or just have it applied without the base one. This is specified in the input scene files as a <code>resetTransform</code> field. Depending on its value, we combine the two matrices.</p>
<p>This is all, really. To be honest I expected instancing would be a lot more work to implement. However, it was pretty easy compared to the transformation part. If you nail down the transformations and all the bounding box calculations together with it, implementing instancing will be a breeze.</p>
<p>I don‚Äôt have many scenes to show instancing. I constructed this one, where our bunny has a companion from now on:</p>
<p><img src="/assets/bunny_mult.png" alt="Bunnies" /><br />
</p>
<p>The original bunny was first translated right, and scaled down. Then the instance of it was translated left and rotated around <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>-axis. The original transform matrix was also applied to the instance (hence it is also scaled down).</p>
<p>This is it for this blog post. I hope it was informative. These topics are hard to grasp without a visual resource, it is hard to explain via text as well. The sad thing is I could not find a resource with an interactive demo or an animated video. If you happen to find one, I would like to take a look at it as well! As always, thanks for reading, and I wish you a great summer!</p>]]></description>
    <pubDate>Fri, 21 Jun 2019 00:00:00 UT</pubDate>
    <guid>https://ozkutuk.me/posts/2019-06-21-adding-movement.html</guid>
    <dc:creator>Berk √ñzk√ºt√ºk</dc:creator>
</item>
<item>
    <title>Ray Marching</title>
    <link>https://ozkutuk.me/posts/2019-06-14-ray-marching.html</link>
    <description><![CDATA[<p>Some time ago, I discovered <a href="https://www.shadertoy.com">Shadertoy</a>. For those who don‚Äôt know, it is a website where people submit their GL shaders and they can be viewed in the browser, inside the Shadertoy‚Äôs environment. There are lots and lots of creative and mind-blowing work there, if you have an interest in graphics, be sure to check it out. Even if you are not interested in the technical side, it can still be an entertaining activity, at least it is for me!</p>
<p>Anyway, if you spend any more than five minutes on Shadertoy, you will see someone mentioning they used ray marching technique to achieve what they did. But what is ray marching? How it is different from ray tracing? Why would one prefer it over ray tracing? To answer these questions, I took a small break from my raytracer and decided to implement a small ray marching engine. Hopefully we will find out the answers along the way. Onwards!</p>
<h2 id="what-is-ray-marching-good-for-anyway">What is ray marching good for anyway?</h2>
<p>While learning a new concept, I always find it helpful to compare with my current way of doing things, and see examples of it being useful. Let‚Äôs see some example cases where ray marching is good for.</p>
<h3 id="fractals">Fractals</h3>
<p>For me, this was the selling point. With traditional ray tracing methods, rendering fractals is either very cumbersome or outright impossible (we will see why in the upcoming sections). I was always fascinated by fractals and even rendered some of the popular 2D ones with Python back in high-school. But rendering 3D fractals? I‚Äôm sold!</p>
<p>Here is what we can possibly achieve with the help of ray marching:</p>
<figure>
<img src="/assets/mandelbulb.jpg" alt="The mandelbulb. Source: Wikipedia" />
<figcaption aria-hidden="true">The mandelbulb. Source: Wikipedia</figcaption>
</figure>
<h3 id="implicit-surfaces-and-csgs">Implicit surfaces and CSGs</h3>
<p>We can extend the idea behind fractals, and actually render other implicit surfaces. These may include some of our common object types like spheres or boxes and some other surfaces which we have not rendered before (torus is one example). We can also combine our surfaces to create new surfaces, which is called <em>Constructive solid geometry</em>, or CSG for short. This way we can express some surfaces with much ease, compared to the explicit alternatives.</p>
<h3 id="real-time-rendering-and-parallelism">Real-time rendering and parallelism</h3>
<p>I have not implemented this myself, so take my word with grain of salt. However, as far as my knowledge goes, ray marching is also a suitable strategy for parallel renderer implementations. The ray marching algorithm is generally involved with only local information at each step. This means less divergence between parallel tasks and in turn more opportunity to parallelize.</p>
<p>Now that we see why ray marching is useful, let‚Äôs have a look in what ways it is different than ray tracing.</p>
<h2 id="back-to-basics-surfaces">Back to basics: surfaces</h2>
<p>In order to understand how ray marching works, let‚Äôs go over what we have been doing with ray tracing up until now. First of all, we need a scene to render, right? In this scene description, we describe lights, camera, materials, and most importantly object data. This object data includes vertex positions and in the case of other specific objects it may include additional data (like radius for sphere). This is defining surface geometry <em>explicitly</em>. This means that we can solve the intersection formula directly for the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> value. An example would be the ray-sphere intersection formula:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>p</mi><mo>‚àí</mo><mi>c</mi><mo stretchy="false">)</mo><mo>‚ãÖ</mo><mo stretchy="false">(</mo><mi>p</mi><mo>‚àí</mo><mi>c</mi><mo stretchy="false">)</mo><mo>‚àí</mo><msup><mi>R</mi><mn>2</mn></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(p - c)\cdot(p - c) - R^2 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">‚àí</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">‚ãÖ</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">‚àí</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">‚àí</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span></p>
<p>Solving the equation for the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> parameter yields:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>t</mi><mo>=</mo><mfrac><mrow><mo>‚àí</mo><mi>d</mi><mo>‚ãÖ</mo><mo stretchy="false">(</mo><mi>o</mi><mo>‚àí</mo><mi>c</mi><mo stretchy="false">)</mo><mo>¬±</mo><msqrt><mrow><mo stretchy="false">(</mo><mi>d</mi><mo>‚ãÖ</mo><mo stretchy="false">(</mo><mi>o</mi><mo>‚àí</mo><mi>c</mi><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>‚àí</mo><mo stretchy="false">(</mo><mi>d</mi><mo>‚ãÖ</mo><mi>d</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>o</mi><mo>‚àí</mo><mi>c</mi><mo stretchy="false">)</mo><mo>‚ãÖ</mo><mo stretchy="false">(</mo><mi>o</mi><mo>‚àí</mo><mi>c</mi><mo stretchy="false">)</mo><mo>‚àí</mo><msup><mi>R</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow></msqrt></mrow><mrow><mi>d</mi><mo>‚ãÖ</mo><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">t = \frac{-d\cdot (o-c) \pm \sqrt{(d\cdot (o-c))^2 - (d \cdot d)((o-c)\cdot (o-c) - R^2)}}{d\cdot d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.316em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.63em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">‚ãÖ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">d</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.695em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">‚àí</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">‚ãÖ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">‚àí</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">¬±</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.935em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">‚ãÖ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">‚àí</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">‚àí</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">‚ãÖ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mopen">((</span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">‚àí</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">‚ãÖ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">‚àí</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">‚àí</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-2.895em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.28em" viewBox="0 0 400000 1296" preserveAspectRatio="xMinYMin slice"><path d="M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067l0 -0c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60zM1001 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.305em;"><span></span></span></span></span></span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>And it has been serving our needs until this point. But sometimes the surface function is very hard (or impossible) to solve. This is where implicit surfaces come to play. In contrast with explicit surfaces, we do not solve the formula directly. But we try out values on the formula and get a response regarding if we intersect or not.</p>
<h2 id="how-ray-marching-works">How ray marching works</h2>
<p>We can summarize the ray marching in two steps:</p>
<ol type="1">
<li>We march forward the ray direction in increments</li>
<li>Check if the distance to the surface is in an acceptable range</li>
</ol>
<p>The thing about first step is, determining the step size is a bit problematic. If the step size is too big, we may possibly miss an intersection. If it is too small, well, it would work <em>in theory</em>, however it would to too computationally costly to actually use. There is a solution to this: we don‚Äôt need to use fixed step sizes. Sphere tracing method is based on this idea, so let‚Äôs explore it further.</p>
<h3 id="sphere-tracing">Sphere tracing</h3>
<p>Sphere tracing is a way to speed up the ray marching algorithm. Our fear was to take too big of a step to miss an intersection. Then we will take <em>the biggest step such that we don‚Äôt miss an intersection</em>. But how? Well, if we knew our distance to the closest thing in the scene from our current position, we could take a step that big and there wouldn‚Äôt be any missed intersection. Hopefully, we represent our scene with exactly that: signed distance functions!</p>
<h3 id="signed-distance-function">Signed distance function</h3>
<p>Signed distance function, despite its cool name, a very simple function. It accepts a point as argument, and returns the shortest distance between that point and some surface. We can use these SDFs to express our surfaces. In fact, we can represent a sphere originating at <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, 0, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> with this SDF:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><msqrt><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><msup><mi>z</mi><mn>2</mn></msup></mrow></msqrt><mo>‚àí</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(x,y,z) = \sqrt{x^2 + y^2 + z^2} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.2333em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0067em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.9667em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.28em" viewBox="0 0 400000 1296" preserveAspectRatio="xMinYMin slice"><path d="M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067l0 -0c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60zM1001 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.2333em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">‚àí</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>We plug our point to the function, and get our distance to the sphere represented by it. Simple stuff.</p>
<p>We haven‚Äôt talked about the second step of ray marching yet, but there is not much to it. We apply the SDF and check the result. There is a reason it is <em>signed</em> distance function, the sign tells us if the point is inside or outside the surface. And we use that information to check if there is an intersection! If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="normal">point</mi><mo>‚Å°</mo><mo stretchy="false">)</mo><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(\operatorname{point}) &lt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">point</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>, the point is inside the surface, hence intersection. We need a bit of a caution here. Remember sphere tracing? We take a step as big as our distance to the scene. But that way, we can never reach inside the surface! Therefore we define a small <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>œµ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">œµ</span></span></span></span> value such that we call it an intersection when <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="normal">point</mi><mo>‚Å°</mo><mo stretchy="false">)</mo><mo>&lt;</mo><mi>œµ</mi></mrow><annotation encoding="application/x-tex">f(\operatorname{point}) &lt; \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">point</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">œµ</span></span></span></span>.</p>
<p>Enough theory, let‚Äôs see some action!</p>
<h2 id="implementation">Implementation</h2>
<p>I almost explained all the theory, so I am about to leave you with some images. Below you will see a render of a pretty common tetrahedron fractal and examples of basic CSG operations.</p>
<figure>
<img src="/assets/tetrahedron.png" alt="Tetrahedron fractal" />
<figcaption aria-hidden="true">Tetrahedron fractal</figcaption>
</figure>
<figure>
<img src="/assets/spheres_union.png" alt="Union of two spheres" />
<figcaption aria-hidden="true">Union of two spheres</figcaption>
</figure>
<figure>
<img src="/assets/spheres_intersection.png" alt="Intersection of two spheres" />
<figcaption aria-hidden="true">Intersection of two spheres</figcaption>
</figure>
<figure>
<img src="/assets/spheres_diff.png" alt="Difference of two spheres" />
<figcaption aria-hidden="true">Difference of two spheres</figcaption>
</figure>
<p>There are some extra stuff regarding the shading and CSGs, but I think there are much better resources to learn them from. If you want to explore them further, you can refer to <a href="http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/">Jamie Wong‚Äôs awesome blog post</a>. Ray marching is a vastly deep topic and there is much to learn. What I did was merely a proof-of-concept, but it was just a little side-project for me. Next time, we will continue on with our raytracer to implement some matrix operations and hopefully instancing. Until then, happy coding!</p>]]></description>
    <pubDate>Fri, 14 Jun 2019 00:00:00 UT</pubDate>
    <guid>https://ozkutuk.me/posts/2019-06-14-ray-marching.html</guid>
    <dc:creator>Berk √ñzk√ºt√ºk</dc:creator>
</item>
<item>
    <title>Raiden, Part II: Going Deeper</title>
    <link>https://ozkutuk.me/posts/2019-04-08-going-deeper.html</link>
    <description><![CDATA[<p>It has been a month since the announcement of my new ray tracer, Raiden. Hopefully, the delay is for a good reason. We have lots of new features to talk about! We will continue from where we left off, addition of refractive surfaces. After we take care of that, we want to improve the render quality. We will achieve this by adding some effects which makes of multisampling.These include anti-aliasing, depth of field, soft shadows and glossy reflections. However, multisampling incurs a good deal of extra runtime cost. Therefore, we first need to speed up the rendering process by using an acceleration structure. There is a lot to cover, so let‚Äôs get right in!</p>
<h2 id="refractive-surfaces">Refractive Surfaces</h2>
<p>Let‚Äôs pickup where we left off, and start with refractive surfaces. This will allow us to render transparent objects, like glass. To be honest, implementing refraction is not that much different than reflection, but there are a few places where things could go wrong. I roughly divided the work into three parts. I then worked through these in the following order:</p>
<ol type="1">
<li>Refraction (just the calculation of direction)</li>
<li>Fresnel computation</li>
<li>Attenuation</li>
</ol>
<p>That is a lot of complicated terms if you don‚Äôt have a physics degree or computer graphics background, so let‚Äôs go over them one-by-one.</p>
<h3 id="refraction">Refraction</h3>
<p>Quoting from Wikipedia:</p>
<blockquote>
<p>In physics refraction is the change in direction of a wave passing from one medium to another or from a gradual change in the medium.</p>
</blockquote>
<p>Hmm, right. So as with reflection, it is a change in direction of our rays. But how do we calculate it? Simple. We use <a href="https://en.wikipedia.org/wiki/Snell%27s_law">Snell‚Äôs law</a>. You can follow the Wikipedia link to see the derivation of the formula, but basically it states that sine of refracted ray‚Äôs angle with respect to normal divided by sine of incoming ray‚Äôs angle is equal to the ratio of two mediums‚Äô refractive indices.</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi>sin</mi><mo>‚Å°</mo><msub><mi>Œ∏</mi><mn>2</mn></msub></mrow><mrow><mi>sin</mi><mo>‚Å°</mo><msub><mi>Œ∏</mi><mn>1</mn></msub></mrow></mfrac><mo>=</mo><mfrac><msub><mi>n</mi><mn>1</mn></msub><msub><mi>n</mi><mn>2</mn></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{\sin{\theta_2}}{\sin{\theta_1}} = \frac{n_1}{n_2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.2074em;vertical-align:-0.836em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">Œ∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">Œ∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.9436em;vertical-align:-0.836em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>Cool, time to test this out. Since we don‚Äôt calculate the reflection/refraction ratio yet, let‚Äôs assume we have 100% refraction for now. We will test this with the <code>cornellbox_glass</code> scene, which is basically <code>cornellbox</code> with a glass sphere. This is the result:</p>
<p><img src="/assets/only_refraction.png" alt="only_refraction" /><br />
</p>
<p>Even with only refraction, the sphere resembles glass. It looks a bit odd, because it does not have reflection, so that is what we will fix next.</p>
<h3 id="fresnel-computation">Fresnel computation</h3>
<p>Fresnel equations describe the ratio of reflection vs.¬†refraction, just what we need. There is a problem though, computing them in an exact manner involves solving some differential equations, which makes them costly and complicated. Hopefully, there exists an approximation method which is quite accurate for our purposes and is used widely in computer graphics. It is called <a href="https://en.wikipedia.org/wiki/Schlick%27s_approximation">Schlick‚Äôs approximation</a>:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>R</mi><mn>0</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mfrac><mrow><msub><mi>n</mi><mn>1</mn></msub><mo>‚àí</mo><msub><mi>n</mi><mn>2</mn></msub></mrow><mrow><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub></mrow></mfrac><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>R</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi>R</mi><mn>0</mn></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>‚àí</mo><msub><mi>R</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>1</mn><mo>‚àí</mo><mi>cos</mi><mo>‚Å°</mo><mi>Œ∏</mi><msup><mo stretchy="false">)</mo><mn>5</mn></msup></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}     R_0 &amp;= (\frac{n_1 - n_2}{n_1 + n_2})^2 \\     R &amp;= R_0 + (1 - R_0)(1 - \cos\theta)^5 \\ \end{align*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.9204em;vertical-align:-1.7102em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.2102em;"><span style="top:-4.2102em;"><span class="pstrut" style="height:3.2603em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.2101em;"><span class="pstrut" style="height:3.2603em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:1.7102em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.2102em;"><span style="top:-4.2102em;"><span class="pstrut" style="height:3.2603em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">‚àí</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.2101em;"><span class="pstrut" style="height:3.2603em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">‚àí</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">‚àí</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">Œ∏</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:1.7102em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>The calculated <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> value is between 0 and 1, and corresponds to the <em>reflection</em> amount compared to refraction. So sum of reflection and refraction factors is always 1. Using this simple computation, we get the following result:</p>
<p><img src="/assets/without_attenuation.png" alt="without_attenuation" /><br />
</p>
<p>The difference is astonishing. It really looks like glass now. Just to be bit more physically correct, there is one final step we have to take.</p>
<h3 id="attenuation">Attenuation</h3>
<p>While light is travelling through a medium, its flux gradually loses intensity. Let‚Äôs implement that now. We will use <a href="https://en.wikipedia.org/wiki/Beer%E2%80%93Lambert_law">Beer‚Äôs law</a> here. To be honest, I don‚Äôt remember enough physics and calculus to understand the derivation of the formula, but in our case it reduces to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">a^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> is the <em>attenuation coefficient</em> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> is the distance to the point where the ray leaves the current medium. With just a few more lines of code:</p>
<p><img src="/assets/full_glass.png" alt="full_glass" /><br />
</p>
<p>It may be difficult to see the difference visually for this scene, but indeed it now feels a bit more realistic. The glass sphere feels like it has more ‚Äúweight‚Äù.</p>
<p>With all three steps completed, we have fully implemented refractive surfaces. There still is a small problem that is more obvious with another scene. Here you see the expected output compared to mine:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Current output</th>
<th style="text-align: center;">Expected output</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><img src="/assets/science.png" /></td>
<td style="text-align: center;"><img src="/assets/expected_science.png" /></td>
</tr>
</tbody>
</table>
<p>However, I am currently happy with the result. I defer the bug-hunting to later time.</p>
<h2 id="getting-faster-introducing-bvh">Getting faster: Introducing BVH</h2>
<p>Now that we have all our surface types implemented, we will focus on speeding up the rendering process. If we profile our ray tracer, we will see that the program spends most of its time on intersection tests. This is no surprise. Let‚Äôs think about it for a second: we shoot rays from camera through <em>every</em> single pixel on our image, and then for each of those rays we test its intersection with <em>all</em> surface primitives in the scene. It is just too much work.</p>
<p>We know the bottleneck, but how can we speed it up? Acceleration structures come to rescue! To explain in an informal fashion, acceleration structures are special data structures which contain our surfaces in an organized way such that it minimizes the number of intersection tests necessary. There are several approaches each with their pros and cons. I picked <a href="https://en.wikipedia.org/wiki/Bounding_volume_hierarchy">BVH (Bounding Volume Hierarchy)</a> due to its relative simplicity and good performance.</p>
<p>BVH is a well-researched acceleration structure and is a good all-around choice. It belongs to object subdivision family of acceleration structures. There are some more advanced variations of BVH which involve surface are heuristics and whatnot, but we will go for the basic vanilla BVH.</p>
<p>The basic idea is to enclose our surfaces with boxes, and before we check the actual intersection with the surface, we first check the intersection between ray and box. If no intersection occurs, great! We do not need to further compute the intersection test only to see it fails. If the ray intersects with the box, then we have to continue on as usual, we did an extra ray-box intersection in the process. But that‚Äôs okay. Ray-box intersection algorithm is pretty cheap, and the speed gains is massive.</p>
<p>Let‚Äôs illustrate with a simple example. Say we have a triangle mesh, consisting of 10,000 triangles. Assume we just have a single bounding box, which is the tightest box such that it fully encloses the mesh. Now, consider a ray that misses the mesh. We first test with the box, and when we see it fails, we halt the testing process for that ray. We just got rid of 10,000 triangle intersection tests, with the cost of having an extra ray-box intersection test in the successful cases. Don‚Äôt you think it is a small price to pay, compared to the burden it takes of our chests? I certainly do.</p>
<p>BVH goes one step further and creates a <em>hierarchy</em> of these bounding volumes, hence the name. It is a tree structure where nodes contain the bounding box and references to two children nodes. The bounding box is split into two (how it is done depends on which partitioning routine was chosen, more on that later.) and they are assigned to left and right sub-trees respectively. We do this until we have bounding boxes which encapsulate only the primitives (i.e.¬†a single triangle of a mesh). These become our leaf nodes.</p>
<p>To sum up simply, BVH is what binary search tree is for arrays. It is simple and effective. No more talking, time to work!</p>
<p>Remember the bunny we have? We will use her for benchmarking our speed. Before we start doing any BVH stuff, let‚Äôs see how fast we can currently render:</p>
<pre><code>Render time                    : 23.031s
# of ray-triangle tests        : 1515354264
# of ray-triangle intersections: 95310</code></pre>
<p>Among all the rays we test for intersection, only 0.006% actually hit anything. All those intersection tests seem wasteful, aren‚Äôt they? Let‚Äôs see what we can do.</p>
<h3 id="one-box-to-bound-them-all">One box to bound them all</h3>
<p>Before we start creating hierarchies of bounding volume, let‚Äôs start with creating a single box encapsulating our surfaces. I created a <code>Box</code> class, which holds the two corners of the box with minimum and maximum values. Then I added it as a member variable to <code>Surface</code> class. Now every surface has an associated bounding box with it. We need to modify the intersection functions to only go on if the ray hits the box first. Adding it only involves prepending <code>if (bounding_box.hit(ray))</code> checks before everything else in the function body. The only thing remaining is the implementation of ray-box intersection test. I will not explain the algorithm here as it is pretty simple, but if you want to read more about it, the idea is same with <a href="https://en.wikipedia.org/wiki/Liang%E2%80%93Barsky_algorithm">Liang‚ÄìBarsky algorithm</a>. Time to test how faster we got:</p>
<pre><code>Render time                    : 10.547s
# of ray-triangle tests        : 666750312
# of ray-triangle intersections: 95310</code></pre>
<p>That is more that 2x speedup. Not bad for such a small addition, is it? But wait, there is more.</p>
<h3 id="bvh-a-bad-one">BVH (a bad one)</h3>
<p>I mentioned that there exists different variations of BVH, and these generally differ by their partitioning methods. Having a good partitioning method is essential for cutting down the render time. I think it is obvious why so. If your sub-trees overlap each other too much, it does not make much of a difference from having a single bounding volume. Makes sense, right?</p>
<p>Then the question is, what is a good splitting method? There are some methods which are not too advanced but still yield good results. I will discuss them in a second. But for now, let‚Äôs settle for something working rather than something optimized. The first method that came to my mind was to simply split the surfaces by the order they reside on memory. If I have <code>Surface[100]</code> in my scene, first 50 items go to the left sub-tree, and the remaining to the right sub-tree. We will recursively call this splitting routine until we have 0 or 1 elements in our nodes‚Äô bounding boxes. Mind you, this is an <em>awful</em> way to construct the tree, but remember, we are just looking for something working for now. Let‚Äôs test this out:</p>
<pre><code>Render time                    : 4.055s
# of ray-triangle tests        : 28219210
# of ray-triangle intersections: 95310
# of ray-sphere tests          : 0
# of ray-sphere intersections  : 0
# of ray-box tests             : 208999586
# of ray-box intersections     : 118547974</code></pre>
<p>Again, we have cut more than half time. However I wouldn‚Äôt rely too much on this statistics, as the result would vary wildly depending on the order of surfaces given in the scene. We can do better.</p>
<h3 id="a-better-splitting-method">A better splitting method</h3>
<p>Among the various ways to split, I wanted to try out <em>mid-point splitting</em>. The idea is simple:</p>
<ol type="1">
<li>Find the mid-point of the longest axis</li>
<li>Find the centroid of each surface primitive.</li>
<li>If it is to the left of mid-point, it goes to left sub-tree. Otherwise, it goes to right sub-tree.</li>
</ol>
<p>Let‚Äôs see how it goes:</p>
<pre><code>Segmentation fault (core dumped)</code></pre>
<p>That didn‚Äôt go as planned. I spent a good amount of time figuring out the problem. It was a case of stack overflow, but why? I think I was not handling an edge case, or did not have a required terminating condition. There were three triangles which all happened to be on the same side of mid-point, therefore it could never reach the terminating condition, no matter how deep the recursion goes. At this point I was pretty demotivated by the lack of success. I tried out a slightly modified version of the said algorithm.</p>
<p>Rather than grouping by centroids‚Äô position compared to mid-point, let‚Äôs just split the sorted surfaces list in half, and assign them to left and right sub-trees respectively. This may possibly be slower, but it would create balanced trees as opposed to mid-point splitting. And here, the final version of my BVH implementation:</p>
<pre><code>Render time                    : 0.264s
# of ray-triangle tests        : 725950
# of ray-triangle intersections: 95310
# of ray-sphere tests          : 0
# of ray-sphere intersections  : 0
# of ray-box tests             : 6290170
# of ray-box intersections     : 3447573</code></pre>
<p>The implementation process was frustrating at times, but it was well-worth the effort. The speedup is really promising. It is almost 88x faster compared to the initial version. We will need that speed when we implement multi-sampling and distribution ray tracing techniques. Now it is time to implement them one by one.</p>
<h2 id="multi-sampling">Multi-sampling</h2>
<p>Before implementing the cool effects multi-sampling provides, we first have to implement multi-sampling itself. Let‚Äôs first briefly explain what multi-sampling is. If we check the main render loop of our implementation, we will see that a single ray is shot through the center of each pixel on our image. That penetrated pixel‚Äôs color value is then set to the calculated color value based on the ray‚Äôs intersection. We <em>sample</em> a single point on the pixel. <em>Multi-sampling</em> is the sampling process of multiple random points within the boundaries of a pixel, and then casting multiple rays through each of them. Then a color value is computed from all of those rays. There exists different approaches to achieve this (as with everything in computer graphics). I will not spend too much time discussing all the possible approaches, just the ones I chose for my implementation.</p>
<p>The process of choosing random points on the pixel is called <em>sampling</em>, and calculating a single value from all the cast rays is called <em>filtering</em>. I chose <em>jittered sampling</em> and <em>box filtering</em> methods respectively.</p>
<p>Jittered sampling is a method to sample random points, but still have them evenly distributed. The pixel is divided into equal sized sub-pixels, and each point is randomly sampled from a distinct sub-pixel. I quickly sketched out a way to calculate the points given the number of samples, and graphed the result for <code>n_samples = 9</code>:</p>
<p><img src="/assets/jittered_graph.png" alt="jittered graph" /><br />
</p>
<p>Box filtering, despite its cool name, is really simple. It is basically averaging the color values gathered from each ray. Higher the samples, better the quality; but also more time to render. You may not notice much of a difference in quality between 9 and 100 samples, and you are right. However, higher number of samples are often necessary to create effects other than anti-aliasing. We will implement a few of them now.</p>
<h3 id="depth-of-field">Depth of Field</h3>
<p>I am pretty sure you are familiar with the depth of field phenomena, where objects out of focus look blurred. What is being ‚Äúout of focus‚Äù anyway? It occurs due to the nature of lenses our cameras have in real life. Every lens has a focal distance associated with it. It is the distance where objects that far will look sharply. To simulate this effect, we need to modify our camera a bit. Rather than having a point camera, we will have lens with pre-determined aperture size and focal distance values. However we can cheat a little bit. We already know the focal distance, therefore we can just send our rays directed to the focal point. This saves us from the computations in which the rays refracted by lens do not reach the eye anymore.</p>
<p>I mentioned focal point in the previous paragraph. How do we find it? Simple. The ray that goes through the center of lens does not bend, therefore we can use it to calculate our focal point. We just shoot a ray through the center and find the point on that ray where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mtext mathvariant="monospace">focal_distance</mtext></mrow><annotation encoding="application/x-tex">t = \texttt{focal\_distance}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7063em;vertical-align:-0.0951em;"></span><span class="mord text"><span class="mord texttt">focal_distance</span></span></span></span></span>. When we find the focal point, we sample points on our pixel and shoot rays originating from those points directed at the focal point. Finally, as in the multi-sampling section, we average the color values from those rays.</p>
<p>Here we have a new scene to test this with. The sphere second from right is in focus. As you see, the others are blurred properly:</p>
<p><img src="/assets/spheres_dof.png" alt="spheres dof" /><br />
</p>
<h3 id="glossy-reflections">Glossy Reflections</h3>
<p>With glossy reflections, we can render imperfect mirrors, like brushed metals. The idea is similar to depth of field, but now applied to reflections. We create the imperfection by redirecting the reflected ray by a small margin. To determine how much to offset we apply, we again sample a random point within a boundary, given within material properties as ‚Äúroughness‚Äù. We only need to find a way to sample this point about the tip of reflected ray. Fortunately, there is a neat way to do this with a bit of linear algebra. We create a new orthonormal basis where the tip of the ray is origin and the direction of the ray is our new <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">+y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord">+</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> axis. We then sample our point in this basis as usual. Finally we transform the point to world coordinates.</p>
<p>Below you will see a render of cornellbox scene, but with imperfect reflections:</p>
<p><img src="/assets/imperfect.png" alt="imperfect" /><br />
</p>
<h3 id="soft-shadows">Soft Shadows</h3>
<p>If you noticed, our shadows are always hard shadows. The reason behind this is that we only had point lights as light sources, therefore each point is either seeing light or it does not. This ‚Äúbinary‚Äù situation makes surfaces either fully in shadow (completely dark) or fully bright. As you might have guessed, if we want to add soft shadows to our renderer, we need to implement area lights.</p>
<p>The first idea that comes to mind might be to implement area lights as bunch of small point lights. And it would actually work okay. However, if we really want it to act like an area light, we have to add a good amount of point lights, and it will increase our render time significantly.</p>
<p>There is a much better way to do it. For any point we want to calculate the ‚Äúshadowness‚Äù, we can sample a point on the area light, and continue the calculation as usual. Since we do multi-sampling, for each pixel we have lots of rays going, and they all will have computed the shadow contribution from different points on the light. It is a cheap and quite ingenious way of implementing area lights.</p>
<p>The actual implementation is almost identical to the glossy reflection implementation. As with the former, we create a new basis about the light‚Äôs position and after we sample a point, we transform using the basis. Here is how it turned out:</p>
<p><img src="/assets/area.png" alt="area" /><br />
</p>
<p>You can see the shadow gradually getting darker at the edges. Also, don‚Äôt be fooled by the super bright area on ceiling. It is not the area light itself, it is bright because the area light is too close to it. The light itself is invisible, as it is with point lights.</p>
<h2 id="conclusion">Conclusion</h2>
<p>That was a lot of stuff to digest, so if you are still reading, congratulations. I believe the most important part was the BVH implementation, since we will start to render more and more complex scenes. With the addition of multi-sampling techniques, we got really cool outputs. However, we are still far from photorealistic results.</p>
<p>Some planned features are still missing (i.e.¬†<code>.ply</code> models), but I did not want to delay the blog post any longer. It will certainly be a part of the following post. We will also implement instancing and transformations. Thanks for reading, and keep following for the updates. I promise you won‚Äôt be waiting for a month this time!</p>]]></description>
    <pubDate>Mon, 08 Apr 2019 00:00:00 UT</pubDate>
    <guid>https://ozkutuk.me/posts/2019-04-08-going-deeper.html</guid>
    <dc:creator>Berk √ñzk√ºt√ºk</dc:creator>
</item>
<item>
    <title>Raiden: The Beginning</title>
    <link>https://ozkutuk.me/posts/2019-03-10-the-beginning.html</link>
    <description><![CDATA[<p>I always had an interest in computer graphics. As a kid, I was amazed by the 3D video games of the time. The experiences I had back then inspired me to pursue software development as a profession. However I did not bother to look into the inner workings of computer graphics until recently. The urge to create inspiring games as I had when I was a child, and the computer graphics class I took last semester motivated me to deep-dive into the vast world of triangles and spheres.</p>
<p>Anyone who is willing to learn more about graphics should probably start out with writing a raytracer. You write code that is simple (from a programming perspective) yet can produce awesome results without relying on any third-party graphics API. Therefore it was mandatory for me to start writing a raytracer from scratch. Here I present you, Raiden. Starting with this post, I will document my development process of Raiden. I will start from the very barebones of a raytracer and hopefully make it into something that I could be proud of in the future, and more importantly, know more about computer graphics in the end.</p>
<p>All the benchmarking is done on my personal laptop, which features an Intel i5-7300HQ processor. Also the project is implemented in C++. However, the performance of a raytracer mostly depend on the efficiency of the data structures and algorithms used. Therefore I believe that any language is equally viable unless you go for an industrial-grade raytracer ‚Äì which I assume you would not bother reading this if you did :) Without further ado, let‚Äôs jump right in!</p>
<h2 id="implementation">Implementation</h2>
<p>I normally write all the code myself in the projects that I am serious about. However, to start working on the actual graphics stuff, I opted to use some external libraries in several parts. Namely, <a href="https://github.com/nothings/stb">stb_image</a> to write PNG images and <a href="https://github.com/leethomason/tinyxml2">tinyxml2</a> to parse scene files given as XML.</p>
<p>I started out by just creating a color gradient and writing it to a file. It took a surprisingly long time. Probably because I was juggling between several different designs regarding the memory representation of the image. I decided to go with a 1D <code>std::vector</code> of <code>Color</code> structs, which consist of 3 <code>uint8_t</code> values for R,G and B. The resulting image is shown below:</p>
<p><img src="/assets/gradient.png" alt="Gradient" /><br />
</p>
<p>In the next step, I started to implement basic raytracing structures, starting out with rays. A lot of vector math was going to ensue, therefore I found it handy to have a simple math library under my belt. I implemented a 3-float vector (<code>vec3f</code> as it is common in the graphics circles) and some basic vector functionality like dot-product and normalization. Later I created a ‚Äúskybox‚Äù to test these out. It casts rays to each pixel coordinate and linearly interpolates between blue and white color by the y-value of the normalized ray. Here is the result:</p>
<p><img src="/assets/skybox.png" alt="Skybox" /><br />
</p>
<p>It is time to implement our surfaces. Sphere is the easiest of all, so I started with it. I had planned to implement basic features using spheres, and later implement other surface types. Calling our object types ‚Äúsurfaces‚Äù may not be pedantically correct, as calling them surface neglects the fact that they have a volume. However, it did not matter for my simple raytracer and it felt like the best name among other options. After implementing a ray-sphere intersection routine, here is our rising sun up in the sky:</p>
<p><img src="/assets/sun.png" alt="Sun" /><br />
</p>
<p>It is important to notice that at this point almost everything is hardcoded. I did not read from scene files yet. Camera is assumed to be at (0,0,0). Aspect-ratio is hardcoded so is the image resolution.</p>
<p>Up next I implemented a very basic material system. It consisted of just a single color. In addition to that, I also wrote a diffuse shading function. I did not care about performance or proper organization at this point. Therefore bunch of stuff was quick-and-dirty hacks. I just wanted to see something on my screen as soon as possible. Here is a render of two spheres, with diffuse shading applied:</p>
<p><img src="/assets/twospheres.png" alt="Two Spheres" /><br />
</p>
<p>Next logical step after diffuse shading was the addition of specular shading. At this point hardcoding everything started to become troublesome, therefore I integrated the XML parser and started reading from the scene files. During the process I somehow broke the working code of diffuse shading and the results started to look as if they were rendered with a cartoon shader. At the time I could not find the problematic piece. After some time I realized I was working with color range between 1-255, and somehow passing this to a function that expected the colors to be normalized (in range 0-1). This also caused my specular shading to be super bright. Here is the faulty render of four spheres:</p>
<figure>
<img src="/assets/faultyspheres.png" alt="Faulty spheres" />
<figcaption aria-hidden="true">Faulty spheres</figcaption>
</figure>
<p>I fixed that mistake, and added shadows, which was only a few lines of code. Here is the same scene with the fix and shadows. You can see the falling shadows at the touching parts of the spheres:</p>
<figure>
<img src="/assets/fixedspheres.png" alt="Spheres, fixed" />
<figcaption aria-hidden="true">Spheres, fixed</figcaption>
</figure>
<p>A mere ~10 lines of code and the results really start to shine with the added reflection:</p>
<figure>
<img src="/assets/reflectedspheres.png" alt="Spheres with reflection" />
<figcaption aria-hidden="true">Spheres with reflection</figcaption>
</figure>
<p>At this point I felt like I saw enough spheres in two days, and wanted to add triangles (which means meshes too). I experienced the most hair-pulling moments at this phase. Because I wrote all my code to expect sphere, and unifying different objects under a single surface interface required a major reorganization in the codebase. During the process lots of subtle bugs occured, long walls of compilation errors were read, and lots of coffee was consumed. In the end, I could get the same outputs as before, but now with the new <code>Surface</code> interface.</p>
<p>On top of the the surface interface, I started writing the triangle class and ray-triangle intersection routine. Everything went smooth as the code was more organized now than before.</p>
<p>Rest of the implementation was removing more hardcoded parts, fixing small bugs (self-shadowing objects and unexpected shadows comes to mind) and reorganizing code.</p>
<p>This is the current state of Raiden. Here are a few fresh renders:</p>
<figure>
<img src="/assets/bunny.png" alt="Stanford bunny, 512x512, 22.116 seconds" />
<figcaption aria-hidden="true">Stanford bunny, 512x512, 22.116 seconds</figcaption>
</figure>
<figure>
<img src="/assets/spheres.png" alt="Spheres, 720x720, 0.678 seconds" />
<figcaption aria-hidden="true">Spheres, 720x720, 0.678 seconds</figcaption>
</figure>
<figure>
<img src="/assets/cornellbox.png" alt="Cornellbox, 800x800, 0.987 seconds" />
<figcaption aria-hidden="true">Cornellbox, 800x800, 0.987 seconds</figcaption>
</figure>
<h2 id="whats-next">What‚Äôs Next?</h2>
<p>The first planned feature is the addition of refractive surfaces, such as glass-like objects. Some other work to be done in the near future are:</p>
<ul>
<li>Acceleration structures, more specifically BVH</li>
<li>Parsing <code>.ply</code> objects</li>
<li>Multisampling</li>
</ul>
<p>Computer graphics is really a wonderful world with very satisfying results at the end. I am excited about the future of this project. I will see you in Part 2, with some new and great additions to Raiden. Thanks for reading and happy coding.</p>]]></description>
    <pubDate>Sun, 10 Mar 2019 00:00:00 UT</pubDate>
    <guid>https://ozkutuk.me/posts/2019-03-10-the-beginning.html</guid>
    <dc:creator>Berk √ñzk√ºt√ºk</dc:creator>
</item>

    </channel>
</rss>
